TOPICS 
--------
-Introduction
  .What is an algorithm
  .What is a program 
  .Aplication, the study of algorithms,  importance of analyzing algorthim,
  .Complexity, RAM model,
  .Why study algorithms
  .Performance efficiency comparison  of two algorithms
  .Methods of proof
  .Algorithm analysis
  .Algorithm analysis
  .Asymptotic and notation
  .function of grrowth rate
  .estimate running time
  .Big-oh notation
  .Big-oh Theorems
  .Asymptomatic notations properties
  .Manipulating  asymptotics notation
  .determining complexities in general 
  .growth rate examples
  .primitive operations
  .counting primitive operations
-Recursion
  .recurrence relations
  .recurrence equations
  .solving recurrences
  .master theorem performance
-Sorting
   .Properties of sorting algorithms
   .bubble sorting 
   .insertion sorting 
   .selection sorting
   .shell sort
   .Heap sort
   .merge sort
   .Quick sort
   .counting sorting
   .radix sort
   .Bucket sort
-Greedy algorithm
   .Definitions 
   .a simple greedy algorithms
   .knapsack problem
   .huffman  code
-Spanning Tree
   .Minimum spanning tree
   .kruskal's algorithms
   .prims algorithms
   .Dijkstra's algorithms
-Dynamic programming 
    .matrix chain maltiplication
    .Longest commo subsequence
    .applications
-Graph algorithms
    .Definitions
    .Adjacency matrix
    .Adjacency list
    .breadth first search
    .depth first search 
    .topological sort
    .strong connected components
    .applications
-Binary search tree
   .Implementations
   .inorder tree walk
   .preorder  tree  walks
   .postorder tree walks
   
   
   
   Purpose
   ---------
   .Algorithm are the heart of computer science.
   .their essential nature is to  automate some aspect of the collecting, organizing  and processing of information.
   .enable making of sense of infiormation to manage, organize and search it, and to use it for practical purposes.
   .efficient algorithm enhances fasteness, little memory and provide guarantees on their performance.
  
   
    Introduction
    -------------
    .Algorithms - rules to be followed in problem solving  operations.
                - finite sequence of well-defined, computer implimentatable instructions, typecally  to solve a class of problems or to perform computations.
                - Are always unambiguous.
                - Used as specifications for performing calculations, data processing, automated reasoning.
                - As an effective method , it can be expressed within a finite amount of space and time and in a well-defined formal language for calculating  a function.
                -sequence of well defined computer  implementable instructions.
                -solves  a class of problems or to perform computations.
                -well-defined computational procedure that takes some values as input and produces some values as output.
                -not dependent not a particular programming language, machine, system or compiler.
                -They are mathematical entities, which can be though of as running on some sort of idealized computer with an ifinite randoem access memory and unlimited word size.
                -algorithm design is all about the mathematical theory behind the design of good programs.
                -Are mathematical objects.
   algorithm's efficiency - is a function of the amount of computational resource it rquires, measured typically as execution time and the amount of space, or memory, that the algorithm uses.
   three thinks you require to present an algorithm -
                     - present a clear, simple and unambiquos description of the algorithm.
                     -present a justification or proof of the algorithm's correctness.
                     -present a worst case analysis of the algorithm efficiency.

algorithm analysis - the basic element includes:
                                              -asymptotics
                                              -summation
                                              -recurrences.
             asymptotics 
                -involves O-notation(big-oh) and its many relatives Ω, Θ, o (“little-Oh”), ω
                -provides us with a way to simpliffy the functions that arise in analyzing  algorithm running  times by ignoring constant factors and concentrating on the trends for  large values of n.
                - ignore constant factors - multiplicative constants are ignored for example, 347n is Θ(n).
                -constant factors appearing exponents cannot be ignored for example, 23n is not O(2n).
  programs - collection of instructions that can be executed by the computer to perform specific task.
           - written by a programer in a programming language.
           - may be executed with the aid of an interpreter.
           -collection of computer programs, libraries and related data are referred to as software.
Why study algorithm - programming is a complex task. 
                    - programming projects involves storing and accessing larg quantities of data efficiently.
                    - many programming projects involves solving compex computational problems for  which simplistic or naive solutions may not be efficient enough.
                    -the complexity may involves numerical data where the topic of algorithms and analysis is important.
                    

 General approaches to algorithm design
               -

Consider the graph shown below.


prims-algorithm-questions-answers-q7


Which of the following edges form the MST of the given graph using Prim’a algorithm, starting from vertex 4.           (1 Mark)
Select one:
 (4-3)(3-2)(2-1)(1-5)
(4-3)(5-3)(2-3)(1-2)
(4-3)(3-5)(5-2)(1-5)
 (4-3)(3-5)(5-1)(1-2)

https://www.sanfoundry.com/fractional-knapsack-problem-multiple-choice-questions-answers-mcqs/



Chapter 4
-----------
Binary search tree(BST)
-------------------------
->Hierarchical data structure with a single pointer to root node.
->Each node has at most two nodes(left and right)
->Each node is ordered by some key data field(s)
->For every node in the tree, its key is greater than its left  child's key and less than its right child's key.


Some BST Terminology
--------------------
->the root node is the top node in the hierarchy
->A child node has exactly one parent node, 
->A parent node has at most two child nodes, sibling nodes share the same parent node
->Every node in the BST is a subtree of the BST rooted at that node.


implementing a search tree
--------------------------
       struct_bst_node {
             int data;
             struct bst_node *left;
             struct bst_node * right;
             };
             typedef struct bst_node ;


->left hold the address of the left child.
->Right  holds the address of the left child
 ->all BST nodes can be accessed through root pointer b traversing left and right bst_node pointer


OPerations on BST
---------------------------
->Natural recursive
 .Each node in the BST is itself a BST
->Some operations:
      -create a BST
      -find node in BST using its key field
      -add a node to the BST
      -Traverse the BST
       vist all the nodes in some order

 
 Creating a BST
 ------------------
    /* a function that creates, initialize, and returns  a new bst_node
    bst_node *createANode(int val){
    bst_node *newnode;
    
    newnode = malloc(sizeof(bst_node);
    if (newnode == NULL){
    return Null;
    }
    
    newnode->data = val;
    newnode->right = newnode -> left = null;
    return newnode;
    }
    bst_node *root = NULL;// an empty BST
    root = CreateANode(35);// a BST w/one node
    if(root != NULL){  //add the left child
    root-> left = CreateANode(22);
    
    
    Finding a Node into the BST
    ----------------------------
    -Use  the search key to direct a recursive binary
    -search for a matching node
      .start at the root node as current node
      .if the search keys' value matches the current node's key then found a match
      .if search key's value is greater than current node's 
               .if the current node has a right  child, search right
               .Else, no matching node in the tree
      .If search key is less than the current node's 
               .If the current node has a left child, search  left
               .Else, no matching node in the tree
     


  Example: Search for 45 in the tree
  -------------------------------------
  ->Start at the root, 45 is greater than 25, search in right subtree
  ->45 is less than 50, search in 50's left subtree
  ->45 is greater than 35, search is 35's right subtree
  ->45 is greater  than 44, but 44 has no  right subtree so 45 is not in the BST


Insert Node into the BST
--------------------------------
->Always insert new node as leaf node
->Start at root node as current node
->if new node's key > current's key 
    .If current node has a left child, search left
    .Else add new node as current's left child


Example: insert 60 in the tree
------------------------------------------
->Start at the root,  60 is greater than 25, search in right subtree
->60 is greater than 50, search in 50's right subtree
->60  is less than 70, search in 70's left subtree
->60 is less than 66, add 60 as 66 left child





Traversals
--------------------
-Visit ever node in the tree and perform some operation on it
    (ex) print out  the data field of each node
-Three steps to a traversal 
    .visit the current node
    .Traverse its left subtree
    .Traverse its right subtree
-The order in which you perform these steps results  in different traversal orders:
     .Pre-order traversal :(1)(2)(3)
     .In-order traversal (2)(1)(3)
     post-order traversal: (2) (3) (1)



Traversal Code
-------------------
/*recurse version of in-order traversal 
*the iterative version is ugly
*/
void InOrder(bst_node *root){
if(root == NULL){
return;
}
InOrder(root->left);//traverse left subtree
Visit(root);
InOrder(root->right);
}
//in main: a call to InOrder passing root
InOrder(root);
//The call stack after the first few
//recursive calls to InOrder(root->left)



Traveral Examples
---------------------
->InOrder(root) visits nodes in the following order:
  4,10,12,15,18,22,24,25,31,35,44,50,66,70,90...
->A pre-order traversal visits nodes  in the following order;
 25,15,10,4,12,22,18,24,50,35,31,44,70,66,90
 ->A post-order traversal visits nodes in the following order:
  4,12,18,24,22,15,31,44,35,66,90,70,50,25


























